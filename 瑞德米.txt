运行
1.运行INIT.bat
2.打开十个结点的代码
3.运行十个结点的myserver
4.Miner1 myclient中startclient除了前三行全注释掉，运行main.go进行初始化（只运行MIner1的）需要等待十个结点都收到block2
5.Miner1 myclient中startclient注释掉前三行，其余解除注释
6.运行所有结点的main.go
7.需要等待挖矿直到myserver出现钱包信息
8.重复6和7进行下一轮挖矿


redis
0库存区块
get index 获得高度
get Bx 获得第x个块的信息
10库存选miner的信息
get Cake获得选择的数（上个块哈希最后两位的十进制）
get 0-9获得每个结点的领地信息
get Winner 获得下轮miner的地址
11库存钱包信息，A0是A的B币余额，A1是A的A币余额（从A-J十个结点，每个结点都有A币和B币两个钱包）

POT (transaction) +简单的POW(较低难度，只用于控制出块速度)
每轮只有一个节点当选为区块生产者，其余节点参与验证
两种币A和B，A可以正常交易，交易时可以根据交易费获得B币，A和B都用UTXO.
transaction设置flag，flag为0代表转的A币1代表转的B币(B币不能用于交易)
交易在打包前和验证区块前需要按照ID从小到大排序，防止交易顺序不同导致merkletree根节点的值不同
节点接到新块后取出hash的后2位(0-255)
所有想要参与块生产的节点将自己B币钱包地址广播(但我懒，A币钱包和B币钱包一样了)，所有结点收到后用地址找到B币的UTXO，并按钱包地址从小到大排序
假设顺序为ABCA的B币占比为50%，则用0.5x255=127.5，B为30%则0.3x255=76.5，C为20%则
0.2x255=51
A的领地为0<=x<127.5
B的领地为127.5<=x<204
C的领地为204<=x<=255
hash后2位在谁的领地中谁就是下一轮的miner比如hash后2位为A8(168) 则节点B为下一个块的生产者(B币越多领地越大，越有可能成为区块生产者)
简单pow:节省算力对硬件需求低，不浪费资源，可以控制出块速度，减少因通信延迟导致的不同步
POT:愿意多使用系统进行交易或多支付交易费的人有更小的可能性做出破坏系统的事，因此这些人有更大的概率被选为区块的生产者从而获得奖励。同时，鼓励用户多交易，多支付交易费可以使系统更加活跃，形成良性循环
改进:
1.可以奖励区块验证者B币，从而鼓励更多节点参与区块验证，提升安全性
2.考虑到拜占庭节点的影响，可以在节点计算出胜者之后广播结果进行投票，得票超过2/3的为下一轮的miner
3.激励设置为30只是为了方便判断交易结果正确性，实际应设置得更小，因为出块速度快

redis是这么存数据的，Cake是上个区块的哈希的最后两位，每个结点L和R之间的范围就是它的领地，Cake掉在谁的领地谁就是下一个区块的miner，addr是钱包地址，balance是B币余额，决定领地大小